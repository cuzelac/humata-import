---
description: Establishes best practices for error handling in Ruby applications
globs: *.rb
alwaysApply: false
---
# Ruby Error Handling Rule

## Description
This rule establishes best practices for error handling in Ruby applications, ensuring robust and maintainable error management.

## Rule
When implementing error handling in Ruby:

1. **Exception Hierarchy**
   - Create custom exceptions inheriting from `StandardError`
   - Group related exceptions in modules
   - Use specific exception classes for specific error cases
   - NEVER rescue `Exception` (base class of all exceptions)

2. **Error Handling Patterns**
   - Use `begin/rescue` blocks sparingly
   - Prefer smaller, focused rescue blocks
   - Always specify the exception class to rescue
   - Include contextual information in error messages
   - Log errors with appropriate severity levels

3. **Custom Exceptions**
   - Name exceptions with `Error` suffix
   - Include relevant error data
   - Provide meaningful error messages
   - Implement `to_s` for custom formatting

4. **Recovery Strategies**
   - Implement retry mechanisms where appropriate
   - Use circuit breakers for external services
   - Provide fallback behaviors
   - Clean up resources in `ensure` blocks

## Examples

✅ Good:
```ruby
module PaymentService
  class PaymentError < StandardError; end
  class InvalidAmountError < PaymentError; end
  class GatewayError < PaymentError; end

  class Processor
    def charge(amount)
      validate_amount(amount)
      process_payment(amount)
    rescue GatewayError => e
      logger.error("Payment gateway error: #{e.message}")
      notify_admin(e)
      raise
    end

    private

    def validate_amount(amount)
      raise InvalidAmountError, "Amount must be positive" unless amount.positive?
    end

    def process_payment(amount)
      # Implementation
    rescue Net::HTTP::Error => e
      raise GatewayError, "Gateway communication failed: #{e.message}"
    end
  end
end
```

❌ Bad:
```ruby
class PaymentProcessor
  def charge(amount)
    begin
      # Rescuing everything is dangerous
      process_payment(amount)
    rescue Exception => e
      # Generic error handling
      puts "Error: #{e}"
      return false
    end
  end

  def process_payment(amount)
    # No input validation
    # No specific error handling
    # Implementation
  end
end
```

## Benefits
- More robust error handling
- Better error reporting and debugging
- Clearer error recovery paths
- Improved system stability
- Better user experience through proper error messages