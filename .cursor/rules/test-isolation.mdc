---
title: Test Isolation and Database Management Rule
description: Establishes critical patterns for test isolation, particularly for database-dependent tests, ensuring that tests run independently without state contamination between test runs.
globs: *_spec.rb
alwaysApply: false
---

# Test Isolation and Database Management Rule

## Description
This rule establishes critical patterns for test isolation, particularly for database-dependent tests, ensuring that tests run independently without state contamination between test runs.

## Rule
When writing tests that use databases or shared resources:

1. **Database Isolation Requirements**
   - Each test MUST get a completely unique database path/connection
   - Database paths MUST use cryptographically random identifiers (e.g., `SecureRandom.hex(8)`)
   - Tests MUST NOT share database files between test runs
   - Database cleanup MUST happen in `teardown` method, not just `setup`

2. **Test Lifecycle Management**
   - Use `setup` and `teardown` methods for Minitest (not `before_each`/`after_each`)
   - `setup` MUST create fresh resources for each test
   - `teardown` MUST clean up all resources created during the test
   - NEVER assume resources from previous tests will be available

3. **Resource Path Generation**
   - Use `Dir.tmpdir` for temporary files in tests
   - Generate unique paths using `SecureRandom.hex(8)` or similar
   - Include test-specific identifiers in resource names
   - Clean up temporary resources even if tests fail

4. **State Verification**
   - Always verify initial state at the beginning of tests
   - Don't assume databases start empty - verify with assertions
   - Check resource counts and states explicitly
   - Add debugging output when troubleshooting isolation issues

## Critical Implementation Patterns

### ✅ Good: Proper Test Isolation
```ruby
class Minitest::Spec
  def setup
    # Generate unique database path for each test
    @temp_db_path = File.join(Dir.tmpdir, "test_#{SecureRandom.hex(8)}.db")
    
    # Create fresh database with schema
    FileUtils.touch(@temp_db_path)
    @db = SQLite3::Database.new(@temp_db_path)
    initialize_schema(@temp_db_path)
    
    # Update environment for this test
    ENV['DB_PATH'] = @temp_db_path
  end
  
  def teardown
    # Clean up database connection
    @db.close if @db && !@db.closed?
    
    # Remove database file
    File.unlink(@temp_db_path) if @temp_db_path && File.exist?(@temp_db_path)
  end
end
```

### ❌ Bad: Shared Database State
```ruby
class Minitest::Spec
  def before_all
    @db_path = "test.db"  # Shared between all tests!
    @db = SQLite3::Database.new(@db_path)
  end
  
  def before_each
    @db.execute('DELETE FROM records')  # Incomplete cleanup
  end
end
```

## Database-Specific Patterns

### Unique Path Generation
```ruby
# Generate cryptographically unique paths
@temp_db_path = File.join(Dir.tmpdir, "humata_test_#{SecureRandom.hex(8)}.db")

# Include test context in paths for debugging
@temp_db_path = File.join(Dir.tmpdir, "#{self.class.name}_#{SecureRandom.hex(8)}.db")
```

### Complete Resource Cleanup
```ruby
def teardown
  # Close connections safely
  @db.close if @db && !@db.closed?
  
  # Remove files safely
  if @temp_db_path && File.exist?(@temp_db_path)
    File.unlink(@temp_db_path)
  end
  
  # Clean up environment
  ENV.delete('DB_PATH')
end
```

### State Verification
```ruby
it 'processes files correctly' do
  # Verify initial state
  files = @db.execute('SELECT COUNT(*) FROM file_records').first.first
  _(files).must_equal 0  # Ensure clean start
  
  # Run test logic
  create_test_files(@db, 3)
  process_files
  
  # Verify final state
  final_count = @db.execute('SELECT COUNT(*) FROM file_records').first.first
  _(final_count).must_equal 3
end
```

## Common Pitfalls to Avoid

1. **Shared Database Files**: Using the same database file across multiple tests
2. **Incomplete Cleanup**: Only cleaning up in `setup` but not `teardown`
3. **State Assumptions**: Assuming tests start with empty/clean state
4. **Resource Leaks**: Not properly closing database connections
5. **Path Collisions**: Using predictable paths that can collide between test runs

## Debugging Test Isolation Issues

When tests pass individually but fail when run together:

1. **Add State Verification**: Check initial state at test start
2. **Add Resource Logging**: Log database paths and connection states
3. **Verify Cleanup**: Ensure `teardown` is actually being called
4. **Check Path Uniqueness**: Verify each test gets unique resource paths
5. **Inspect Shared State**: Look for global variables or singletons

## Benefits
- Tests run reliably in any order
- No flaky tests due to state contamination
- Easier debugging when tests fail
- Parallel test execution becomes possible
- Faster development feedback loops

## Enforcement
- Code review must verify proper test isolation patterns
- All database-dependent tests must use unique database paths
- Tests that fail when run together indicate isolation problems
- CI/CD should run tests in random order to catch isolation issues

## Notes
- This rule is critical for preventing the "works alone, fails together" test pattern
- Applies to all shared resources: databases, files, network ports, etc.
- Essential for maintaining fast, reliable test suites
- Complements `test-performance.mdc` for comprehensive test reliability
