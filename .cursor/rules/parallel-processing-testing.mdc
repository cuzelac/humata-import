---
title: Parallel Processing and Threading Testing Rule
description: Parallel Processing and Threading Testing Rule
globs: *_spec.rb
alwaysApply: false
---

# Parallel Processing and Threading Testing Rule

## Description
This rule establishes patterns for testing parallel processing and multi-threaded code, ensuring that concurrent operations are properly tested while maintaining test reliability and performance.

## Rule
When testing parallel processing and multi-threaded code:

1. **Mock Detection for Threading**
   - Threading logic MUST detect mock clients and fall back to sequential processing
   - Mock clients MUST NOT be passed to thread-local resource creation
   - Tests MUST use `--threads 1` or equivalent to force sequential execution
   - Thread-safe mock detection MUST handle edge cases safely

2. **Resource Isolation in Tests**
   - Each test MUST use unique database connections and file paths
   - Thread-local resources MUST be properly mocked or stubbed
   - Tests MUST NOT create actual threads when using mock clients
   - Resource cleanup MUST handle both threaded and sequential execution paths

3. **Performance and Timing**
   - Tests MUST stub `sleep` calls to avoid actual delays
   - Retry logic MUST be tested without real time delays
   - Rate limiting MUST be tested with mock time providers
   - Thread pool creation MUST be avoided in test environments

4. **Error Handling in Concurrent Code**
   - Error isolation between threads MUST be tested
   - Thread failure recovery MUST be verified
   - Shared error state MUST be properly synchronized
   - Error aggregation across threads MUST be tested

## Critical Implementation Patterns

### ✅ Good: Mock-Aware Threading Logic
```ruby
def process_uploads_parallel(client, files, options)
  # Detect mock clients and use sequential processing for tests
  if is_mock_client?(client)
    logger.info "Using sequential processing for mock client (testing mode)"
    process_uploads_sequential(client, files, options)
  else
    logger.info "Using parallel processing for real client"
    process_uploads_with_threads(client, files, options)
  end
end

def is_mock_client?(client)
  # Safe mock detection that handles anonymous classes
  (client.class.name&.include?('Mock') ||
   client.respond_to?(:verify) ||
   (client.respond_to?(:upload_file) && !client.respond_to?(:instance_variable_get)))
end
```

### ✅ Good: Sequential Testing with Thread Count
```ruby
it 'processes files with controlled threading' do
  client_mock = create_mock_client
  
  upload = Upload.new({ database: @temp_db_path })
  # Force sequential execution in tests
  upload.run(['--folder-id', 'test-123', '--threads', '1'], humata_client: client_mock)
  
  verify_processing_results
end
```

### ✅ Good: Sleep Stubbing for Retry Logic
```ruby
it 'handles retry logic with exponential backoff' do
  client_mock = create_failing_then_succeeding_mock
  
  upload = Upload.new({ database: @temp_db_path })
  
  # Stub sleep to avoid actual delays in tests
  upload.stub :sleep, nil do
    upload.run(['--folder-id', 'test-123', '--max-retries', '3'], humata_client: client_mock)
  end
  
  verify_retry_behavior
end
```

### ❌ Bad: Real Threading in Tests
```ruby
it 'processes files in parallel' do
  client_mock = create_mock_client
  
  # This creates real threads and can cause issues with mocks
  upload.run(['--folder-id', 'test-123', '--threads', '4'], humata_client: client_mock)
end
```

### ❌ Bad: Unstubbed Sleep Calls
```ruby
it 'handles retry delays' do
  client_mock = create_failing_mock
  
  # This will cause real delays in tests
  upload.run(['--folder-id', 'test-123', '--retry-delay', '5'], humata_client: client_mock)
end
```

## Thread-Safe Resource Management

### Database Connection Handling
```ruby
def get_thread_database_connection
  # In tests, return the main test database connection
  if ENV['TEST_ENV']
    @db  # Use shared test database
  else
    # In production, create thread-local connection
    Database.connect(@options[:database])
  end
end
```

### Thread-Local Client Creation
```ruby
def create_thread_client(base_client)
  # For testing, if the client is a mock, just return it
  if is_mock_client?(base_client)
    return base_client
  end
  
  # For real clients, create a new instance
  begin
    ExternalClient.new(
      api_key: base_client.instance_variable_get(:@api_key),
      base_url: base_client.instance_variable_get(:@base_url)
    )
  rescue
    # Fallback: return the original client
    base_client
  end
end
```

## Error Handling Testing Patterns

### Thread Error Isolation
```ruby
it 'isolates errors between processing threads' do
  # Create mixed success/failure scenario
  files = create_test_files(3)
  client_mock = create_mixed_result_mock
  
  upload = Upload.new({ database: @temp_db_path })
  upload.run(['--folder-id', 'test-123', '--threads', '1'], humata_client: client_mock)
  
  # Verify that one failure doesn't affect other files
  results = get_processing_results
  _(results.count { |r| r[:status] == 'completed' }).must_equal 2
  _(results.count { |r| r[:status] == 'failed' }).must_equal 1
end
```

### Signal Handling Testing
```ruby
it 'handles graceful shutdown during processing' do
  files = create_test_files(5)
  client_mock = create_slow_mock_client
  
  upload = Upload.new({ database: @temp_db_path })
  
  # Simulate shutdown request
  upload.instance_variable_set(:@shutdown_requested, true)
  
  upload.run(['--folder-id', 'test-123', '--threads', '1'], humata_client: client_mock)
  
  # Verify graceful handling
  results = get_processing_results
  _(results.size).must_be :>=, 0  # Some files may be processed
end
```

## Performance Testing Patterns

### Throughput Testing Without Real Delays
```ruby
it 'improves throughput with parallel processing' do
  files = create_test_files(10)
  
  # Mock client that simulates processing time without actual delays
  client_mock = Class.new do
    def initialize
      @call_count = 0
      @start_time = Time.now
    end
    
    def upload_file(url, folder_id)
      @call_count += 1
      # Simulate processing without actual delay
      { 'data' => { 'pdf' => { 'id' => "doc-#{@call_count}" } } }
    end
    
    def verify; end
    
    def processing_time
      Time.now - @start_time
    end
  end.new
  
  start_time = Time.now
  upload.run(['--folder-id', 'test-123', '--threads', '1'], humata_client: client_mock)
  end_time = Time.now
  
  # Verify performance without real delays
  processing_time = end_time - start_time
  _(processing_time).must_be :<, 1.0  # Should complete quickly
end
```

## Common Threading Test Pitfalls

1. **Real Thread Creation**: Creating actual threads with mock clients
2. **Unstubbed Delays**: Not stubbing `sleep` calls in retry logic
3. **Resource Conflicts**: Multiple threads accessing the same test database
4. **Mock State Corruption**: Thread-unsafe mock objects causing state issues
5. **Timing Dependencies**: Tests that depend on actual thread timing

## Mock Client Threading Considerations

### Thread-Safe Mock Design
```ruby
# Thread-safe mock client
client_mock = Class.new do
  def initialize
    @call_count = 0
    @mutex = Mutex.new
  end
  
  def upload_file(url, folder_id)
    @mutex.synchronize do
      @call_count += 1
      # Return deterministic response based on call count
      { 'data' => { 'pdf' => { 'id' => "doc-#{@call_count}" } } }
    end
  end
  
  def verify; end
end.new
```

## Testing Strategies

### 1. Sequential Testing Strategy
- Use `--threads 1` to force sequential execution
- Test core logic without threading complexity
- Verify business logic correctness

### 2. Mock Detection Strategy
- Implement robust mock detection in production code
- Fall back to sequential processing for mock clients
- Test both code paths (parallel and sequential)

### 3. Resource Isolation Strategy
- Each test gets unique database/file paths
- Stub thread-local resource creation
- Clean up resources in test teardown

## Benefits
- Reliable testing of concurrent code without race conditions
- Fast test execution without real threading overhead
- Comprehensive coverage of both sequential and parallel code paths
- Predictable test behavior regardless of system load

## Enforcement
- All parallel processing code must detect and handle mock clients
- Tests involving retry logic must stub sleep calls
- Threading tests must use controlled thread counts
- Resource isolation must be verified for all concurrent operations

## Notes
- This rule complements `ruby-concurrency.mdc` for production threading patterns
- Essential for testing complex concurrent operations reliably
- Helps prevent flaky tests due to timing issues or race conditions
- Critical for maintaining fast, deterministic test suites