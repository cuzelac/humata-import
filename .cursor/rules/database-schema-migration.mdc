---
description: Database Schema Migration Rule
globs: *.rb
alwaysApply: false
---

## Description
This rule ensures that any database schema changes are accompanied by migration scripts to update existing databases, maintaining data consistency and enabling seamless upgrades.

## Rule
When updating the database schema:

1. **Migration Script Requirement**
   - MUST create a migration script for any schema changes
   - MUST place migration scripts in `scripts/migrations/` directory
   - MUST use sequential numbering (001_, 002_, etc.) for migration files
   - MUST include both up and down migration methods
   - MUST be idempotent (safe to run multiple times)

2. **Migration Script Structure**
   - MUST inherit from `HumataImport::Migration` base class
   - MUST implement `up` method for applying changes
   - MUST implement `down` method for rolling back changes
   - MUST include descriptive comments explaining the changes
   - MUST handle existing data appropriately

3. **Migration Execution**
   - MUST provide a way to run migrations via CLI command
   - MUST support running individual migrations or all pending migrations
   - MUST track migration status in database
   - MUST be idempotent (safe to run multiple times)

4. **Backward Compatibility**
   - MUST ensure migrations can be run on existing databases
   - MUST handle missing columns gracefully
   - MUST provide rollback capability for failed migrations
   - MUST preserve existing data during schema updates

5. **Idempotency**
   - MUST be safe to run multiple times without side effects
   - MUST check for existing state before making changes
   - MUST use conditional logic (e.g., `IF NOT EXISTS`, `UNLESS EXISTS`)
   - MUST handle partial failures gracefully

## Implementation Guidelines

### Migration File Naming
```
scripts/migrations/
├── 001_add_humata_pages.rb
├── 002_add_new_field.rb
└── 003_update_indexes.rb
```

### Migration Class Structure
```ruby
module HumataImport
  module Migrations
    class AddHumataPages < Migration
      def up
        # Add new column if it doesn't exist
        unless column_exists?(:file_records, :humata_pages)
          add_column :file_records, :humata_pages, :integer
        end
      end

      def down
        # Remove column if it exists
        if column_exists?(:file_records, :humata_pages)
          remove_column :file_records, :humata_pages
        end
      end
    end
  end
end
```

### Migration Base Class
```ruby
module HumataImport
  class Migration
    attr_reader :db

    def initialize(db)
      @db = db
    end

    def up
      raise NotImplementedError, "Subclasses must implement #up"
    end

    def down
      raise NotImplementedError, "Subclasses must implement #down"
    end

    protected

    def column_exists?(table, column)
      # Implementation for checking column existence
    end

    def add_column(table, column, type)
      # Implementation for adding columns
    end

    def remove_column(table, column)
      # Implementation for removing columns
    end
  end
end
```

### CLI Migration Command
```ruby
class Migrate < Base
  def run(args)
    # Parse migration options
    # Run pending migrations
    # Provide status and rollback options
  end
end
```

## Examples

### ✅ Good: Complete Migration Implementation
```ruby
# scripts/migrations/001_add_humata_pages.rb
module HumataImport
  module Migrations
    class AddHumataPages < Migration
      def up
        # Add new column if it doesn't exist (idempotent)
        unless column_exists?(:file_records, :humata_pages)
          @db.execute(<<-SQL)
            ALTER TABLE file_records 
            ADD COLUMN humata_pages INTEGER
          SQL
          logger.info "Added humata_pages column to file_records table"
        else
          logger.info "humata_pages column already exists in file_records table"
        end
      end

      def down
        # Remove column if it exists (idempotent)
        if column_exists?(:file_records, :humata_pages)
          @db.execute(<<-SQL)
            ALTER TABLE file_records 
            DROP COLUMN humata_pages
          SQL
          logger.info "Removed humata_pages column from file_records table"
        else
          logger.info "humata_pages column does not exist in file_records table"
        end
      end

      private

      def column_exists?(table, column)
        columns = @db.execute("PRAGMA table_info(#{table})").map { |col| col[1] }
        columns.include?(column.to_s)
      end
    end
  end
end
```

### ❌ Bad: Missing Migration Script
```ruby
# Direct schema change without migration
class Verify < Base
  def run(args)
    # This would fail on existing databases without the new column
    @db.execute("UPDATE file_records SET humata_pages = ? WHERE id = ?", [pages, id])
  end
end
```

## Benefits
- **Data Consistency**: Ensures existing databases can be upgraded
- **Rollback Safety**: Provides ability to undo schema changes
- **Production Safety**: Enables safe schema updates in production
- **Version Control**: Tracks schema evolution over time
- **Team Collaboration**: Multiple developers can apply schema changes consistently

## Enforcement
- Code review must reject schema changes without migration scripts
- All database schema modifications must include corresponding migrations
- Migration scripts must be tested on existing database instances
- Rollback functionality must be verified before deployment

## Exceptions
- Initial database creation can skip migrations
- Test-only schema changes can skip migrations
- When in doubt, create a migration script

## Notes
- This rule complements `cursor-rules-location` for rule organization
- Follows Ruby database migration best practices
- Ensures consistent schema management across the project
- Applies to all Ruby files that modify database schemas