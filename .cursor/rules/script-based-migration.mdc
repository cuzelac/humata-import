# Script-Based Database Migration Rule

## Description
This rule establishes best practices for script-based database migrations, particularly for projects that choose simplicity over complex migration frameworks, based on the successful implementation of the Humata Import duplicate detection system.

## Rule
When implementing database migrations using scripts:

1. **Migration Script Requirements**
   - MUST create a single, comprehensive migration script in `scripts/update_schema.rb`
   - MUST ensure scripts are idempotent (safe to run multiple times)
   - MUST include automatic backup creation before any schema changes
   - MUST provide clear progress feedback and error messages

2. **Migration Strategy**
   - MUST use additive-only migrations (ADD COLUMN, CREATE INDEX)
   - MUST NEVER modify existing data or drop columns
   - MUST check existing state before making changes
   - MUST handle partial failures gracefully with backup restoration

3. **Backup and Recovery**
   - MUST create timestamped backups before any schema changes
   - MUST implement automatic backup restoration on failure
   - MUST clean up backup files on successful completion
   - MUST provide clear rollback instructions

4. **Integration Requirements**
   - MUST update both migration script and schema initialization code
   - MUST coordinate with data population scripts when needed
   - MUST provide clear migration workflow documentation
   - MUST test migrations on existing databases

## Implementation Guidelines

### Migration Script Structure
```ruby
class SchemaUpdater
  def initialize(db_path = './import_session.db')
    @db_path = db_path
    @db = nil
  end

  def run
    puts "üîß Updating database schema: #{@db_path}"
    
    # 1. Validate database exists
    validate_database_exists
    
    # 2. Create backup
    create_backup
    
    # 3. Apply schema updates
    apply_schema_updates
    
    # 4. Verify final state
    verify_schema
    
    # 5. Clean up backup
    cleanup_backup
  rescue => e
    # 6. Restore backup on failure
    restore_backup
    raise
  end
end
```

### Backup Management
```ruby
def create_backup
  backup_path = "#{@db_path}.backup.#{Time.now.to_i}"
  FileUtils.cp(@db_path, backup_path)
  @backup_path = backup_path
  puts "üíæ Created backup: #{backup_path}"
end

def restore_backup
  return unless backup_exists?
  
  puts "üîÑ Restoring backup due to error..."
  FileUtils.cp(@backup_path, @db_path)
  puts "‚úÖ Backup restored"
end

def cleanup_backup
  return unless backup_exists?
  
  File.delete(@backup_path)
  puts "üßπ Cleaned up backup file"
end
```

### Schema Update Methods
```ruby
def add_missing_column(column_name, column_type)
  if column_exists?(column_name)
    puts "‚úì Column '#{column_name}' already exists"
    return 0
  end

  puts "‚ûï Adding column '#{column_name}' (#{column_type})..."
  
  begin
    @db.execute("ALTER TABLE file_records ADD COLUMN #{column_name} #{column_type}")
    puts "‚úÖ Successfully added column '#{column_name}'"
    return 1
  rescue SQLite3::Exception => e
    puts "‚ùå Failed to add column '#{column_name}': #{e.message}"
    raise
  end
end

def add_missing_index(index_name, columns)
  if index_exists?(index_name)
    puts "‚úì Index '#{index_name}' already exists"
    return 0
  end

  puts "‚ûï Adding index '#{index_name}' on columns: #{columns}..."
  
  begin
    @db.execute("CREATE INDEX #{index_name} ON file_records (#{columns})")
    puts "‚úÖ Successfully added index '#{index_name}'"
    return 1
  rescue SQLite3::Exception => e
    puts "‚ùå Failed to add index '#{index_name}': #{e.message}"
    raise
  end
end
```

### Integration with Data Population
```ruby
def populate_existing_file_hashes
  puts "\nüîç Checking file hash population needs..."
  
  records_without_hash = @db.get_first_value("SELECT COUNT(*) FROM file_records WHERE file_hash IS NULL")
  records_without_hash = records_without_hash || 0
  
  if records_without_hash > 0
    puts "üìä Found #{records_without_hash} records without file_hash"
    puts "üí° To populate file hashes for duplicate detection, run:"
    puts "   ruby scripts/populate_file_hashes.rb #{@db_path}"
    puts "\n   This will enable duplicate detection for all existing files."
  else
    puts "‚úÖ All records already have file_hash values"
    puts "   Duplicate detection is fully functional!"
  end
end
```

## Examples

### ‚úÖ Good: Complete Migration Implementation
```ruby
# scripts/update_schema.rb
class SchemaUpdater
  def run
    puts "üîß Updating database schema: #{@db_path}"
    
    unless File.exist?(@db_path)
      puts "‚ùå Database file not found: #{@db_path}"
      exit 1
    end

    begin
      @db = SQLite3::Database.new(@db_path)
      
      # Backup the database first
      create_backup
      
      # Check current schema
      current_columns = get_current_columns
      puts "üìã Current columns: #{current_columns.join(', ')}"
      
      # Apply updates
      updates_applied = 0
      updates_applied += add_missing_column('file_hash', 'TEXT')
      updates_applied += add_missing_column('duplicate_of_gdrive_id', 'TEXT')
      updates_applied += add_missing_index('idx_files_file_hash', 'file_hash')
      
      if updates_applied > 0
        puts "‚úÖ Schema update completed! Applied #{updates_applied} updates."
      else
        puts "‚úÖ Schema is already up to date!"
      end
      
      # Check for additional steps needed
      populate_existing_file_hashes
      
    rescue SQLite3::Exception => e
      puts "‚ùå Database error: #{e.message}"
      restore_backup if backup_exists?
      exit 1
    ensure
      @db&.close
      cleanup_backup
    end
  end
end
```

### ‚ùå Bad: Incomplete Migration
```ruby
# Missing backup creation
# No error handling
# No rollback mechanism
# No progress feedback
```

## Migration Workflow

### 1. Schema Update Process
```bash
# Update existing database
ruby scripts/update_schema.rb [database_path]

# Script will:
# - Create backup
# - Add missing columns and indexes
# - Provide feedback on additional steps needed
# - Clean up backup on success
```

### 2. Data Population Process
```bash
# Populate data for new schema
ruby scripts/populate_file_hashes.rb [database_path]

# Script will:
# - Check for records needing population
# - Process all records efficiently
# - Provide progress feedback
# - Report final results
```

### 3. Validation Process
```bash
# Validate migration success
ruby scripts/production_validation.rb [database_path]

# Script will:
# - Verify all schema changes applied
# - Test functionality with new schema
# - Validate data integrity
# - Assess production readiness
```

## Benefits

### **Simplicity**
- **Easy to understand**: Single script handles all migrations
- **No framework complexity**: Direct SQL operations
- **Immediate value**: Can be implemented quickly
- **Easy debugging**: Clear, linear execution flow

### **Safety**
- **Automatic backups**: No data loss risk
- **Idempotent operations**: Safe to run multiple times
- **Error recovery**: Automatic rollback on failure
- **Progress tracking**: Clear visibility into migration status

### **Maintainability**
- **Single source of truth**: One script for all migrations
- **Easy coordination**: Simple to update and test
- **Clear documentation**: Self-documenting migration process
- **Version control friendly**: Easy to track changes

## Decision Rationale

The project chose a **script-based approach** over a complex migration framework for:

1. **Immediate Need**: Schema updates were needed quickly
2. **Codebase Impact**: Full migration framework would require refactoring ~50+ database calls
3. **Risk Assessment**: Large refactoring could introduce bugs in working code
4. **Team Velocity**: Focus on new features rather than rewriting infrastructure
5. **Future Flexibility**: Script approach can be replaced with migration framework later

## Enforcement
- Code review must reject schema changes without updating both migration script and schema initialization
- All database schema modifications must include corresponding migration script changes
- Migration scripts must be tested on existing database instances
- Backup and restore functionality must be verified before deployment

## Notes
- This rule complements `database-schema-migration.mdc` for comprehensive database management
- Based on successful implementation of duplicate detection system migrations
- Provides 80% of migration framework benefits with 20% of complexity
- Can be replaced with full migration framework in future if needed
description:
globs:
alwaysApply: true
---
