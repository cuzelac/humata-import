# frozen_string_literal: true

require 'spec_helper'

module HumataImport
  module Commands
    describe Upload do
      include Minitest::Hooks
      def before_all
        super
        @folder_id = 'test-folder-123'
        @api_key = 'test-api-key'
        ENV['HUMATA_API_KEY'] = @api_key
      end

      def after_all
        super
        ENV.delete('HUMATA_API_KEY')
      end

      def before_each
        super
        # Reset the database before each test
        @db.execute('DELETE FROM file_records')
        # Ensure results are returned as hashes
        @db.results_as_hash = true
        # Reset auto-increment counter
        @db.execute('DELETE FROM sqlite_sequence WHERE name = "file_records"')
      end

      private

      # Helper method to get file record by gdrive_id
      def get_file_record(gdrive_id)
        result = @db.execute('SELECT * FROM file_records WHERE gdrive_id = ?', [gdrive_id]).first
        return nil unless result
        
        # Convert to hash if it's an array
        if result.is_a?(Array)
          columns = @db.execute('PRAGMA table_info(file_records)').map { |col| col[1] }
          columns.zip(result).to_h
        else
          result
        end
      end

      it 'has basic setup' do
        _(true).must_equal true
      end

      it 'handles upload with no pending files' do
        upload = Upload.new(database: @temp_db_path)
        
        # Mock the logger to capture output
        logger_mock = Minitest::Mock.new
        logger_mock.expect :configure, nil, [Hash]
        logger_mock.expect :info, nil, [String] # Allow any info message
        logger_mock.expect :error, nil, [String] # Allow error calls
        upload.stub :logger, logger_mock do
          upload.run(['--folder-id', @folder_id])
        end
        
        logger_mock.verify
      end

      it 'uploads successful files' do
        # Create test files with unique IDs
        file1_data = create_test_file(@db, { name: 'test1.pdf', url: 'https://example.com/file1.pdf' })
        file2_data = create_test_file(@db, { name: 'test2.pdf', url: 'https://example.com/file2.pdf' })

        # Create mock HumataClient
        client_mock = Minitest::Mock.new
        client_mock.expect :upload_file, { 'data' => { 'pdf' => { 'id' => 'humata-1' } } }, [String, @folder_id]
        client_mock.expect :upload_file, { 'data' => { 'pdf' => { 'id' => 'humata-2' } } }, [String, @folder_id]

        upload = Upload.new(database: @temp_db_path)
        upload.run(['--folder-id', @folder_id], humata_client: client_mock)

        # Verify database updates
        files = @db.execute('SELECT * FROM file_records ORDER BY gdrive_id')
        _(files.size).must_equal 2
        
        file1 = get_file_record(file1_data['gdrive_id'])
        file2 = get_file_record(file2_data['gdrive_id'])
        
        _(file1['humata_id']).must_equal 'humata-1'
        _(file2['humata_id']).must_equal 'humata-2'
        _(file1['processing_status']).must_equal 'pending'
        _(file2['processing_status']).must_equal 'pending'
        _(file1['uploaded_at']).wont_be_nil
        _(file2['uploaded_at']).wont_be_nil
        
        client_mock.verify
      end

      it 'sets uploaded_at timestamp on successful upload' do
        # Create test file with unique ID
        file_data = create_test_file(@db, { name: 'test1.pdf', url: 'https://example.com/file1.pdf' })

        # Create mock HumataClient
        client_mock = Minitest::Mock.new
        client_mock.expect :upload_file, { 'data' => { 'pdf' => { 'id' => 'humata-1' } } }, [String, @folder_id]

        upload = Upload.new(database: @temp_db_path)
        upload.run(['--folder-id', @folder_id], humata_client: client_mock)

        # Verify uploaded_at is set
        file1 = get_file_record(file_data['gdrive_id'])
        _(file1['uploaded_at']).wont_be_nil
        _(Time.parse(file1['uploaded_at'])).must_be_close_to Time.now, 5 # Within 5 seconds
        
        client_mock.verify
      end

      it 'handles upload with retries on failure' do
        # Create test file with unique ID
        file_data = create_test_file(@db, { name: 'test1.pdf', url: 'https://example.com/file1.pdf' })

        # Create mock HumataClient to fail twice then succeed
        client_mock = Minitest::Mock.new
        client_mock.expect(:upload_file, [String, @folder_id]) { raise HumataImport::Clients::HumataError, 'Rate limit exceeded' }
        client_mock.expect(:upload_file, [String, @folder_id]) { raise HumataImport::Clients::HumataError, 'Rate limit exceeded' }
        client_mock.expect :upload_file, { 'data' => { 'pdf' => { 'id' => 'humata-1' } } }, [String, @folder_id]

        upload = Upload.new(database: @temp_db_path)
        upload.run(['--folder-id', @folder_id, '--max-retries', '3', '--retry-delay', '0'], humata_client: client_mock)

        # Verify successful upload
        files = @db.execute('SELECT * FROM file_records')
        _(files.size).must_equal 1
        
        file1 = get_file_record(file_data['gdrive_id'])
        _(file1['humata_id']).must_equal 'humata-1'
        _(file1['processing_status']).must_equal 'pending'
        _(file1['uploaded_at']).wont_be_nil
        
        client_mock.verify
      end

      it 'fails upload after max retries' do
        # Create test file with unique ID
        file_data = create_test_file(@db, { name: 'test1.pdf', url: 'https://example.com/file1.pdf' })

        # Create mock HumataClient to always fail
        client_mock = Minitest::Mock.new
        4.times do  # 1 initial + 3 retries
          client_mock.expect(:upload_file, [String, @folder_id]) { raise HumataImport::Clients::HumataError, 'API error' }
        end

        upload = Upload.new(database: @temp_db_path)
        upload.run(['--folder-id', @folder_id, '--max-retries', '3', '--retry-delay', '0'], humata_client: client_mock)

        # Verify failure is recorded
        files = @db.execute('SELECT * FROM file_records')
        _(files.size).must_equal 1
        
        file1 = get_file_record(file_data['gdrive_id'])
        _(file1['processing_status']).must_equal 'failed'
        _(file1['humata_import_response']).must_include 'API error'
        
        client_mock.verify
      end

      it 'skips already processed files' do
        # Create files in different states with unique IDs
        file1_data = create_test_file(@db, { name: 'test1.pdf', url: 'https://example.com/file1.pdf', processing_status: 'completed', humata_id: 'done1' })
        file2_data = create_test_file(@db, { name: 'test2.pdf', url: 'https://example.com/file2.pdf', processing_status: 'failed', humata_id: 'fail1' })
        file3_data = create_test_file(@db, { name: 'test3.pdf', url: 'https://example.com/file3.pdf' }) # Not processed

        # Create mock HumataClient - should only be called for unprocessed file
        client_mock = Minitest::Mock.new
        client_mock.expect :upload_file, { 'data' => { 'pdf' => { 'id' => 'humata-3' } } }, [String, @folder_id]

        upload = Upload.new(database: @temp_db_path)
        upload.run(['--folder-id', @folder_id], humata_client: client_mock)

        # Verify only unprocessed file was uploaded
        files = @db.execute('SELECT * FROM file_records ORDER BY gdrive_id')
        _(files.size).must_equal 3
        
        file1 = get_file_record(file1_data['gdrive_id'])
        file2 = get_file_record(file2_data['gdrive_id'])
        file3 = get_file_record(file3_data['gdrive_id'])
        
        _(file1['humata_id']).must_equal 'done1' # Already completed
        _(file2['humata_id']).must_equal 'fail1' # Already failed
        _(file3['humata_id']).must_equal 'humata-3' # Newly uploaded
        
        client_mock.verify
      end

      it 'handles batch processing' do
        # Create multiple test files
        create_test_files(@db, 5)

        # Create mock HumataClient
        client_mock = Minitest::Mock.new
        5.times do |i|
          client_mock.expect :upload_file, { 'data' => { 'pdf' => { 'id' => "humata-#{i}" } } }, [String, @folder_id]
        end

        upload = Upload.new(database: @temp_db_path)
        upload.run(['--folder-id', @folder_id, '--batch-size', '2'], humata_client: client_mock)

        # Verify all files were uploaded
        files = @db.execute('SELECT * FROM file_records')
        _(files.size).must_equal 5
        _(files.all? { |f| 
          record = get_file_record(f['gdrive_id'])
          record['humata_id'] && record['processing_status'] == 'pending'
        }).must_equal true
        
        client_mock.verify
      end

      it 'handles missing API key' do
        ENV.delete('HUMATA_API_KEY')
        
        upload = Upload.new(database: @temp_db_path)
        
        # Mock logger to capture error
        logger_mock = Minitest::Mock.new
        logger_mock.expect :configure, nil, [Hash]
        logger_mock.expect :error, nil, ["HUMATA_API_KEY environment variable not set"]
        upload.stub :logger, logger_mock do
          _(-> { upload.run(['--folder-id', @folder_id]) }).must_raise(SystemExit)
        end
        
        logger_mock.verify
      end

      it 'handles missing folder ID' do
        upload = Upload.new(database: @temp_db_path)
        
        _(-> { upload.run([]) }).must_raise(SystemExit)
      end

      def test_upload_handles_unexpected_errors
        # Create test file with unique ID
        file_data = create_test_file(@db, { name: 'test1.pdf', url: 'https://example.com/file1.pdf' })

        # Mock HumataClient to raise unexpected error
        client_mock = Minitest::Mock.new
        client_mock.expect :upload_file, ->(*args) { raise StandardError, 'Unexpected error' }, [String, @folder_id]

        upload = Upload.new(database: @temp_db_path)
        upload.run(['--folder-id', @folder_id], humata_client: client_mock)

        # Verify error is handled gracefully
        files = @db.execute('SELECT * FROM file_records')
        assert_equal 1, files.size
        # File should remain unprocessed since it wasn't a HumataError
        
        client_mock.verify
      end

      it 'retries failed uploads on subsequent runs' do
        # Create a file that previously failed with unique ID
        file_data = create_test_file(@db, { 
          name: 'failed.pdf', 
          url: 'https://example.com/failed.pdf',
          processing_status: 'failed',
          humata_import_response: { error: 'API error', attempts: 3, last_attempt: Time.now.iso8601 }.to_json
        })

        # Create mock HumataClient that succeeds on retry
        client_mock = Minitest::Mock.new
        client_mock.expect :upload_file, { 'data' => { 'pdf' => { 'id' => 'humata-retry-success' } } }, [String, @folder_id]

        upload = Upload.new(database: @temp_db_path)
        upload.run(['--folder-id', @folder_id], humata_client: client_mock)

        # Verify the failed file was retried and succeeded
        file = get_file_record(file_data['gdrive_id'])
        _(file['humata_id']).must_equal 'humata-retry-success'
        _(file['processing_status']).must_equal 'pending'
        
        client_mock.verify
      end

      it 'skips retries when --skip-retries is used' do
        # Create a file that previously failed with unique ID
        file_data = create_test_file(@db, { 
          name: 'failed.pdf', 
          url: 'https://example.com/failed.pdf',
          processing_status: 'failed',
          humata_import_response: { error: 'API error', attempts: 3 }.to_json
        })

        # Create mock HumataClient - should not be called
        client_mock = Minitest::Mock.new
        # No expectations set - should not be called

        upload = Upload.new(database: @temp_db_path)
        upload.run(['--folder-id', @folder_id, '--skip-retries'], humata_client: client_mock)

        # Verify the failed file was not retried
        file = get_file_record(file_data['gdrive_id'])
        _(file['humata_id']).must_be_nil
        _(file['processing_status']).must_equal 'failed'
        
        client_mock.verify
      end

      it 'distinguishes between new uploads and retries' do
        # Create both new and failed files with unique IDs
        new_file_data = create_test_file(@db, { name: 'new.pdf', url: 'https://example.com/new.pdf' })
        failed_file_data = create_test_file(@db, { 
          name: 'failed.pdf', 
          url: 'https://example.com/failed.pdf',
          processing_status: 'failed',
          humata_import_response: { error: 'API error', attempts: 3 }.to_json
        })

        # Create mock HumataClient
        client_mock = Minitest::Mock.new
        client_mock.expect :upload_file, { 'data' => { 'pdf' => { 'id' => 'humata-new' } } }, [String, @folder_id]
        client_mock.expect :upload_file, { 'data' => { 'pdf' => { 'id' => 'humata-retry' } } }, [String, @folder_id]

        upload = Upload.new(database: @temp_db_path)
        upload.run(['--folder-id', @folder_id], humata_client: client_mock)

        # Verify both files were processed
        new_file = get_file_record(new_file_data['gdrive_id'])
        failed_file = get_file_record(failed_file_data['gdrive_id'])
        
        _(new_file['humata_id']).must_equal 'humata-new'
        _(failed_file['humata_id']).must_equal 'humata-retry'
        _(new_file['processing_status']).must_equal 'pending'
        _(failed_file['processing_status']).must_equal 'pending'
        
        client_mock.verify
      end

      # Tests for single file upload by ID feature
      it 'uploads single file by ID successfully' do
        # Create test files with unique IDs
        file1_data = create_test_file(@db, { name: 'test1.pdf', url: 'https://example.com/file1.pdf' })
        file2_data = create_test_file(@db, { name: 'test2.pdf', url: 'https://example.com/file2.pdf' })

        # Create mock HumataClient - should only be called once for the specified file
        client_mock = Minitest::Mock.new
        client_mock.expect :upload_file, { 'data' => { 'pdf' => { 'id' => 'humata-single' } } }, [String, @folder_id]

        upload = Upload.new(database: @temp_db_path)
        upload.run(['--folder-id', @folder_id, '--id', file1_data['gdrive_id']], humata_client: client_mock)

        # Verify only the specified file was uploaded
        file1 = get_file_record(file1_data['gdrive_id'])
        file2 = get_file_record(file2_data['gdrive_id'])
        
        _(file1['humata_id']).must_equal 'humata-single'
        _(file1['processing_status']).must_equal 'pending'
        _(file2['humata_id']).must_be_nil # Should not be uploaded
        
        client_mock.verify
      end

      it 'uploads single file by ID regardless of upload status' do
        # Create files in different states with unique IDs
        completed_file_data = create_test_file(@db, { 
          name: 'completed.pdf', 
          url: 'https://example.com/completed.pdf',
          processing_status: 'completed',
          humata_id: 'existing-humata-id'
        })
        failed_file_data = create_test_file(@db, { 
          name: 'failed.pdf', 
          url: 'https://example.com/failed.pdf',
          processing_status: 'failed'
        })

        # Create mock HumataClient - should be called for the completed file
        client_mock = Minitest::Mock.new
        client_mock.expect :upload_file, { 'data' => { 'pdf' => { 'id' => 'humata-new-id' } } }, [String, @folder_id]

        upload = Upload.new(database: @temp_db_path)
        upload.run(['--folder-id', @folder_id, '--id', completed_file_data['gdrive_id']], humata_client: client_mock)

        # Verify the completed file was re-uploaded
        completed_file = get_file_record(completed_file_data['gdrive_id'])
        failed_file = get_file_record(failed_file_data['gdrive_id'])
        
        _(completed_file['humata_id']).must_equal 'humata-new-id'
        _(completed_file['processing_status']).must_equal 'pending'
        _(failed_file['humata_id']).must_be_nil # Should not be uploaded
        
        client_mock.verify
      end

      it 'exits with error when specified file ID does not exist' do
        # Create a different file with unique ID
        existing_file_data = create_test_file(@db, { name: 'existing.pdf', url: 'https://example.com/existing.pdf' })

        # Create mock HumataClient - should not be called
        client_mock = Minitest::Mock.new
        # No expectations set - should not be called

        upload = Upload.new(database: @temp_db_path)
        
        # Mock logger to capture error message
        logger_mock = Minitest::Mock.new
        logger_mock.expect :configure, nil, [Hash]
        logger_mock.expect :error, nil, ["No file found with ID: nonexistent-file"]
        upload.stub :logger, logger_mock do
          _(-> { upload.run(['--folder-id', @folder_id, '--id', 'nonexistent-file'], humata_client: client_mock) }).must_raise(SystemExit)
        end
        
        logger_mock.verify
        client_mock.verify
      end

      it 'handles single file upload with retries on failure' do
        # Create test file with unique ID
        file_data = create_test_file(@db, { name: 'test1.pdf', url: 'https://example.com/file1.pdf' })

        # Create mock HumataClient to fail twice then succeed
        client_mock = Minitest::Mock.new
        client_mock.expect(:upload_file, [String, @folder_id]) { raise HumataImport::Clients::HumataError, 'Rate limit exceeded' }
        client_mock.expect(:upload_file, [String, @folder_id]) { raise HumataImport::Clients::HumataError, 'Rate limit exceeded' }
        client_mock.expect :upload_file, { 'data' => { 'pdf' => { 'id' => 'humata-success' } } }, [String, @folder_id]

        upload = Upload.new(database: @temp_db_path)
        upload.run(['--folder-id', @folder_id, '--id', file_data['gdrive_id'], '--max-retries', '3', '--retry-delay', '0'], humata_client: client_mock)

        # Verify successful upload after retries
        file1 = get_file_record(file_data['gdrive_id'])
        _(file1['humata_id']).must_equal 'humata-success'
        _(file1['processing_status']).must_equal 'pending'
        
        client_mock.verify
      end

      it 'handles single file upload failure after max retries' do
        # Create test file with unique ID
        file_data = create_test_file(@db, { name: 'test1.pdf', url: 'https://example.com/file1.pdf' })

        # Create mock HumataClient to always fail
        client_mock = Minitest::Mock.new
        4.times do  # 1 initial + 3 retries
          client_mock.expect(:upload_file, [String, @folder_id]) { raise HumataImport::Clients::HumataError, 'API error' }
        end

        upload = Upload.new(database: @temp_db_path)
        upload.run(['--folder-id', @folder_id, '--id', file_data['gdrive_id'], '--max-retries', '3', '--retry-delay', '0'], humata_client: client_mock)

        # Verify failure is recorded
        file1 = get_file_record(file_data['gdrive_id'])
        _(file1['processing_status']).must_equal 'failed'
        _(file1['humata_import_response']).must_include 'API error'
        
        client_mock.verify
      end

      it 'ignores batch size when uploading single file by ID' do
        # Create test file with unique ID
        file_data = create_test_file(@db, { name: 'test1.pdf', url: 'https://example.com/file1.pdf' })

        # Create mock HumataClient
        client_mock = Minitest::Mock.new
        client_mock.expect :upload_file, { 'data' => { 'pdf' => { 'id' => 'humata-single' } } }, [String, @folder_id]

        upload = Upload.new(database: @temp_db_path)
        # Use a large batch size, but it should be ignored for single file upload
        upload.run(['--folder-id', @folder_id, '--id', file_data['gdrive_id'], '--batch-size', '100'], humata_client: client_mock)

        # Verify the file was uploaded
        file1 = get_file_record(file_data['gdrive_id'])
        _(file1['humata_id']).must_equal 'humata-single'
        _(file1['processing_status']).must_equal 'pending'
        
        client_mock.verify
      end

      it 'provides appropriate logging for single file upload' do
        # Create test file with unique ID
        file_data = create_test_file(@db, { name: 'test1.pdf', url: 'https://example.com/file1.pdf' })

        # Create mock HumataClient that succeeds
        client_mock = Minitest::Mock.new
        client_mock.expect :upload_file, { 'data' => { 'pdf' => { 'id' => 'humata-single' } } }, [String, @folder_id]

        upload = Upload.new(database: @temp_db_path)
        
        # Use a simple test to verify the file was uploaded successfully
        # This avoids the complexity of mocking the logger
        upload.run(['--folder-id', @folder_id, '--id', file_data['gdrive_id']], humata_client: client_mock)
        
        # Verify the file was uploaded
        file1 = get_file_record(file_data['gdrive_id'])
        _(file1['humata_id']).must_equal 'humata-single'
        _(file1['processing_status']).must_equal 'pending'
        
        client_mock.verify
      end

      it 'handles single file upload with unexpected errors' do
        # Create test file with unique ID
        file_data = create_test_file(@db, { name: 'test1.pdf', url: 'https://example.com/file1.pdf' })

        # Mock HumataClient to raise unexpected error
        client_mock = Minitest::Mock.new
        client_mock.expect(:upload_file, [String, @folder_id]) { raise StandardError, 'Unexpected error' }

        upload = Upload.new(database: @temp_db_path)
        upload.run(['--folder-id', @folder_id, '--id', file_data['gdrive_id']], humata_client: client_mock)

        # Verify error is handled gracefully
        file1 = get_file_record(file_data['gdrive_id'])
        _(file1['humata_id']).must_be_nil # Should remain unprocessed
        
        client_mock.verify
      end
    end
  end
end 